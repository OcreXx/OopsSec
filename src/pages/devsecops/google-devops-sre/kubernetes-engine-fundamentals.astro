---
import BaseLayout from "../../../layouts/BaseLayout.astro";
---
<BaseLayout title="Kubernetes Engine: Foundations - Google Cloud Platform">
  <div class="page-wrapper">
    <!-- Sidebar Navigation -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h3>‚òÅÔ∏è Cloud Fundamentals</h3>
      </div>
      
      <!-- Modules Navigation with Submenu -->
      <nav class="sidebar-nav modules-nav">
        <!-- Introducci√≥n Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/introduccion" class="nav-link module-link">
            <span class="module-icon">üìö</span>
            <span class="module-text">Introducci√≥n a GCP</span>
          </a>
        </div>

        <!-- Recursos Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/recursos" class="nav-link module-link">
            <span class="module-icon">üîê</span>
            <span class="module-text">Recursos y Acceso</span>
          </a>
        </div>

        <!-- VMs y Redes Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/vms-redes" class="nav-link module-link">
            <span class="module-icon">üåê</span>
            <span class="module-text">VMs y Redes</span>
          </a>
        </div>

        <!-- Almacenamiento Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/almacenamiento" class="nav-link module-link">
            <span class="module-icon">üíæ</span>
            <span class="module-text">Almacenamiento</span>
          </a>
        </div>

        <!-- Contenedores Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/contenedores" class="nav-link module-link">
            <span class="module-icon">üì¶</span>
            <span class="module-text">Contenedores</span>
          </a>
        </div>

        <!-- Aplicaciones Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/aplicaciones" class="nav-link module-link">
            <span class="module-icon">üöÄ</span>
            <span class="module-text">Aplicaciones</span>
          </a>
        </div>

        <!-- Prompt Engineering Module -->
        <div class="module-item">
          <a href="/devsecops/google-devops-sre/prompt-engineering" class="nav-link module-link">
            <span class="module-icon">ü§ñ</span>
            <span class="module-text">Prompt Engineering</span>
          </a>
        </div>

        <!-- Kubernetes Engine Module - ACTIVE -->
        <div class="module-item expanded">
          <a href="/devsecops/google-devops-sre/kubernetes-engine-fundamentals" class="nav-link module-link active">
            <span class="module-icon">‚öôÔ∏è</span>
            <span class="module-text">Kubernetes Engine</span>
          </a>
          <div class="submenu">
            <a href="#introduccion-contenedores" class="submenu-link">Introducci√≥n a Contenedores</a>
            <a href="#introduccion-kubernetes" class="submenu-link">Introducci√≥n a Kubernetes</a>
            <a href="#opciones-computo" class="submenu-link">Opciones de C√≥mputo</a>
            <a href="#conceptos-kubernetes" class="submenu-link">Conceptos de Kubernetes</a>
            <a href="#conceptos-gke" class="submenu-link">Conceptos de GKE</a>
            <a href="#gestion-objetos" class="submenu-link">Gesti√≥n de Objetos</a>
            <a href="#migrate-anthos" class="submenu-link">Migrate for Anthos</a>
          </div>
        </div>
      </nav>

      <div class="sidebar-footer">
        <a href="/devsecops/google-devops-sre/cloud-fundamentals" class="back-link">‚Üê Volver al Hub</a>
      </div>
    </aside>

    <!-- Main Content -->
    <div class="gcp-container">
      <!-- Hero Section -->
      <div class="gcp-hero">
        <h1 class="gcp-title">Kubernetes Engine: Foundations</h1>
        <p class="gcp-subtitle">Fundamentos de contenedores, Kubernetes y orquestaci√≥n en Google Cloud</p>
      </div>

      <div class="content-section">

      <!-- Content Sections -->
      <div class="content-wrapper">
      
      <!-- Section 1: Introducci√≥n a Contenedores -->
      <section id="introduccion-contenedores" class="content-section">
        <h2 class="section-title">üì¶ Introducci√≥n a Contenedores</h2>
        
        <div class="content-card">
          <h3>Evoluci√≥n hacia la virtualizaci√≥n</h3>
          <p>
            Antes, cada aplicaci√≥n se ejecutaba en su propio servidor f√≠sico, lo que hac√≠a el despliegue lento, costoso, 
            con mucho desperdicio de recursos y poca portabilidad.
          </p>
          <p>
            La virtualizaci√≥n introdujo el <strong>hipervisor</strong>, permitiendo crear varias m√°quinas virtuales sobre 
            un mismo hardware. Esto aceler√≥ los despliegues y aprovech√≥ mejor los recursos, pero las VMs segu√≠an siendo 
            pesadas: cada una incluye su propio sistema operativo, tarda en arrancar y no se mueve f√°cilmente entre 
            distintos hipervisores.
          </p>
          <p>
            Ejecutar varias apps dentro de una misma VM tampoco funcionaba bien: no hab√≠a aislamiento, pod√≠an estorbarse 
            con recursos o dependencias, y actualizar una pod√≠a romper otra. La alternativa de usar <strong>una VM por 
            aplicaci√≥n</strong> resolvi√≥ el aislamiento, pero escalaba muy mal porque cada VM duplicaba un sistema 
            operativo completo.
          </p>
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch01.png" alt="Evoluci√≥n de la virtualizaci√≥n" loading="lazy">
          </div>
          <p>
            Una forma m√°s eficiente de resolver los problemas de dependencias es abstraer solo el espacio de usuario, 
            sin virtualizar toda la m√°quina ni el sistema operativo. Esto permite empaquetar la aplicaci√≥n junto con 
            sus dependencias sin incluir un sistema operativo completo. A esta t√©cnica se le conoce como 
            <strong>contenedores</strong>, y representa un avance clave frente a las VMs al ser m√°s ligeros, r√°pidos 
            y portables.
          </p>
        </div>

        <div class="content-card">
          <h3>Contenedores e Im√°genes</h3>
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch02.png" alt="Contenedores e Im√°genes" loading="lazy">
          </div>
          <p>
            Los contenedores no son una caracter√≠stica primitiva de Linux; su capacidad para <strong>aislar cargas de 
            trabajo</strong> proviene de la combinaci√≥n de varias tecnolog√≠as fundamentales:
          </p>
          <ul>
            <li><strong>Procesos de Linux:</strong> cada proceso tiene su propio espacio de memoria virtual, separado de los dem√°s.</li>
            <li><strong>Namespaces de Linux:</strong> controlan lo que una aplicaci√≥n puede ver (IDs de proceso, directorios, IPs, etc.).</li>
            <li><strong>cgroups (control groups):</strong> limitan los recursos que una aplicaci√≥n puede usar (CPU, memoria, I/O).</li>
            <li><strong>Sistemas de archivos en capas:</strong> permiten encapsular aplicaciones y dependencias en capas limpias.</li>
          </ul>
          
          <h4>Im√°genes de contenedor</h4>
          <p>
            Una <strong>imagen de contenedor</strong> est√° estructurada en capas. Se construye usando instrucciones de 
            un archivo de manifiesto (por ejemplo, un <strong>Dockerfile</strong>).
          </p>
          <ul>
            <li>Cada instrucci√≥n del Dockerfile genera una <strong>capa de solo lectura</strong> dentro de la imagen.</li>
            <li>Cuando se ejecuta el contenedor, se a√±ade una <strong>capa superior temporal y escribible</strong>.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Capas en un Dockerfile</h3>
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch03.png" alt="Capas en Dockerfile" loading="lazy">
          </div>
          <p>
            Un <strong>Dockerfile</strong> crea una imagen de contenedor a partir de varias capas:
          </p>
          <ul>
            <li><strong>FROM:</strong> crea la capa base desde una imagen p√∫blica (ej: Ubuntu).</li>
            <li><strong>COPY:</strong> agrega archivos desde el directorio actual.</li>
            <li><strong>RUN:</strong> construye la aplicaci√≥n (usando <code>make</code>, <code>npm</code>, etc.).</li>
            <li><strong>CMD/ENTRYPOINT:</strong> define qu√© comando se ejecutar√° al iniciar el contenedor.</li>
          </ul>
          
          <div class="tip-box">
            <strong>üí° Buena pr√°ctica:</strong> Ordena las instrucciones desde las menos propensas a cambiar hasta las 
            m√°s propensas. Esto optimiza la reutilizaci√≥n de capas en futuras construcciones.
          </div>
        </div>

        <div class="content-card">
          <h3>Buenas pr√°cticas con contenedores</h3>
          <p>
            Actualmente, la mejor pr√°ctica es <strong>no construir tu aplicaci√≥n en el mismo contenedor que vas a 
            desplegar</strong>. Esto evita que herramientas de construcci√≥n innecesarias aumenten la complejidad o 
            se conviertan en un vector de ataque.
          </p>
          <ul>
            <li><strong>Construcci√≥n multi-stage:</strong> un contenedor construye, otro ejecuta.</li>
            <li><strong>Capa escribible:</strong> los cambios en tiempo de ejecuci√≥n son ef√≠meros.</li>
            <li><strong>Datos persistentes:</strong> deben almacenarse fuera del contenedor.</li>
            <li><strong>Compartici√≥n de im√°genes:</strong> m√∫ltiples contenedores pueden usar la misma imagen base.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Uso de im√°genes y herramientas de construcci√≥n</h3><p>
            Cuando se construye un contenedor, <strong>no se copia toda la imagen</strong>, sino solo las capas con 
            diferencias. Esto hace la construcci√≥n mucho m√°s r√°pida que las VMs.
          </p>
          <ul>
            <li><strong>Im√°genes base p√∫blicas:</strong> Ubuntu, Alpine, Nginx, etc.</li>
            <li><strong>Artifact Registry:</strong> almacena im√°genes con integraci√≥n a IAM, KMS y Cloud Build.</li>
            <li><strong>Cloud Build:</strong> servicio gestionado que automatiza la construcci√≥n de contenedores.</li>
          </ul>
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch04.png" alt="Cloud Build" loading="lazy">
          </div>
        </div>
      </section>

      <!-- Section 2: Introducci√≥n a Kubernetes -->
      <section id="kubernetes" class="content-section">
        <h2 class="section-title">‚ò∏Ô∏è Kubernetes</h2>
        
        <div class="content-card">
          <h3>¬øQu√© es Kubernetes?</h3>
          <p>
            Kubernetes automatiza el despliegue, escalado, balanceo de carga, logging, monitoreo y otras tareas de 
            gesti√≥n de aplicaciones en contenedores. Combina capacidades de PaaS con la flexibilidad de IaaS.
          </p>
          <ul>
            <li><strong>Automatizaci√≥n declarativa:</strong> mantiene el estado deseado autom√°ticamente.</li>
            <li><strong>Soporte para m√∫ltiples cargas:</strong> stateless, stateful, batch jobs, daemons.</li>
            <li><strong>Escalado autom√°tico:</strong> basado en utilizaci√≥n de recursos.</li>
            <li><strong>Recursos configurables:</strong> l√≠mites y solicitudes de CPU/memoria.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Google Kubernetes Engine (GKE)</h3>
          <p>
            <strong>GKE</strong> es la soluci√≥n Kubernetes completamente gestionada de Google Cloud, con sistemas 
            operativos optimizados para contenedores.
          </p>
          <ul>
            <li><strong>Modo Autopilot:</strong> Google gestiona configuraci√≥n, nodos, seguridad y escalado.</li>
            <li><strong>Auto-repair:</strong> repara nodos defectuosos autom√°ticamente.</li>
            <li><strong>Auto-upgrade:</strong> mantiene la versi√≥n estable m√°s reciente.</li>
            <li><strong>Integraciones:</strong> IAM, VPC, Cloud Monitoring, Cloud Build, Artifact Registry.</li>
          </ul>
          <div class="tip-box">
            <strong>‚úÖ Ideal para:</strong> aplicaciones contenerizadas, sistemas distribuidos cloud-native y entornos 
            h√≠bridos sin vendor lock-in.
          </div>
        </div>
      </section>

      <!-- Section 3: Opciones de C√≥mputo -->
      <section id="compute-options" class="content-section">
        <h2 class="section-title">‚öôÔ∏è Opciones de C√≥mputo en GCP</h2>
        
        <div class="content-card">
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch05.png" alt="Opciones de C√≥mputo" loading="lazy">
          </div>
        </div>

        <div class="content-card">
          <h3>Compute Engine</h3>
          <p>M√°quinas virtuales altamente configurables con control total.</p>
          <ul>
            <li><strong>Persistent disks:</strong> hasta 64 TB con snapshots.</li>
            <li><strong>Local SSDs:</strong> IOPS extremadamente alto.</li>
            <li><strong>VMs preemptibles:</strong> costos reducidos para cargas tolerantes a interrupciones.</li>
            <li><strong>Facturaci√≥n por segundo</strong> y autoscaling global.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>App Engine</h3>
          <p>Plataforma totalmente gestionada (PaaS) sin gesti√≥n de servidores.</p>
          <ul>
            <li>Solo subes tu c√≥digo, Google gestiona el resto.</li>
            <li>Control de versiones y divisi√≥n de tr√°fico integrada.</li>
            <li>Integraci√≥n con Monitoring, Logging y Error Reporting.</li>
            <li><strong>Casos de uso:</strong> sitios web, APIs RESTful, backends m√≥viles.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Google Kubernetes Engine</h3>
          <p>Orquestaci√≥n de contenedores con Kubernetes gestionado.</p>
          <ul>
            <li>Automatiza despliegue, escalado y monitoreo.</li>
            <li>Integraci√≥n con Cloud Build y Artifact Registry.</li>
            <li>Perfecto para microservicios y aplicaciones cloud-native.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Cloud Run</h3>
          <p>Ejecuci√≥n serverless de contenedores stateless.</p>
          <ul>
            <li>Escala autom√°ticamente desde cero.</li>
            <li>Pagas solo por tiempo de ejecuci√≥n (100ms de granularidad).</li>
            <li>Activado por peticiones HTTP o eventos.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Cloud Functions</h3>
          <p>Funciones serverless basadas en eventos.</p>
          <ul>
            <li>C√≥digo ligero que responde a eventos de la nube.</li>
            <li>Escalado autom√°tico y alta disponibilidad.</li>
            <li><strong>Casos de uso:</strong> webhooks, pipelines de datos, automatizaci√≥n.</li>
          </ul>
        </div>
      </section>

      <!-- Section 4: Conceptos de Kubernetes -->
      <section id="conceptos-kubernetes" class="content-section">
        <h2 class="section-title">üß© Conceptos de Kubernetes</h2>
        
        <div class="content-card">
          <h3>Componentes de un Cl√∫ster</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch07.png" alt="Componentes de Kubernetes" loading="lazy">
          </div>

          <p>
            Un cl√∫ster de Kubernetes tiene dos tipos de nodos: el <strong>plano de control</strong> (control plane) 
            y los <strong>nodos de trabajo</strong> (worker nodes).
          </p>
        </div>

        <div class="content-card">
          <h3>Plano de Control (Control Plane)</h3>
          <p>
            En GKE, los ordenadores que componen tus cl√∫steres son m√°quinas virtuales. Un ordenador se llama 
            <strong>plano de control</strong> y los otros simplemente se llaman <strong>nodos</strong>. El trabajo 
            de los nodos es ejecutar las cargas de trabajo. El trabajo del plano de control es coordinar todo el cl√∫ster.
          </p>
          <p>Varios componentes cr√≠ticos de Kubernetes se ejecutan en el plano de control:</p>
          
          <h4>kube-apiserver</h4>
          <p>
            El √∫nico componente con el que interact√∫as directamente. Su trabajo es aceptar comandos que ven o cambian 
            el estado del cl√∫ster, incluido el lanzamiento de pods. El trabajo de <code>kubectl</code> es conectarse 
            al kube-apiserver y comunicarse usando la API de Kubernetes. Cualquier consulta o cambio hacia el estado 
            del cl√∫ster debe dirigirse al kube-apiserver.
          </p>
          
          <h4>etcd</h4>
          <p>
            Es la <strong>base de datos del cl√∫ster</strong>. Su trabajo es almacenar de manera confiable el estado 
            del cl√∫ster, los datos de configuraci√≥n, qu√© pods deber√≠an estar ejecut√°ndose y d√≥nde. El kube-apiserver 
            interact√∫a con la base de datos en nombre del resto del sistema.
          </p>
          
          <h4>kube-scheduler</h4>
          <p>
            Responsable de <strong>programar (scheduling)</strong> los pods en los nodos. Siempre que descubre un 
            objeto pod que a√∫n no tiene una asignaci√≥n a un nodo, elige un nodo y simplemente escribe el nombre de 
            ese nodo en el objeto pod. Conoce el estado de todos los nodos y obedecer√° las restricciones que definas 
            sobre d√≥nde puede ejecutarse un pod, bas√°ndose en hardware, software y pol√≠ticas.
          </p>
          
          <h4>kube-controller-manager</h4>
          <p>
            Monitoriza continuamente el estado del cl√∫ster a trav√©s del kube-apiserver e intentar√° realizar cambios 
            para lograr el estado deseado. Se llama administrador de controladores porque muchos objetos de Kubernetes 
            son gestionados por bucles de c√≥digo llamados <strong>controladores</strong>. Los controladores pueden 
            agrupar contenedores y gestionar cargas de trabajo. Otros tipos de controladores tienen responsabilidades 
            a nivel de sistema. Por ejemplo, el trabajo del <strong>controlador de nodo</strong> es monitorizar y 
            responder cuando un nodo est√° desconectado.
          </p>
          
          <h4>cloud-controller-manager</h4>
          <p>
            Gestiona controladores que interact√∫an con los proveedores de nube subyacentes, responsables de traer 
            caracter√≠sticas de Google Cloud como balanceadores de carga y vol√∫menes de almacenamiento cuando los necesitas.
          </p>
        </div>

        <div class="content-card">
          <h3>Componentes de Nodo</h3>
          <p>Cada nodo ejecuta tambi√©n una peque√±a familia de componentes del plano de control:</p>
          
          <h4>kubelet</h4>
          <p>
            Puedes pensar en un kubelet como el <strong>agente de Kubernetes en cada nodo</strong>. Cuando el 
            kube-apiserver quiere iniciar un pod en un nodo, se conecta al kubelet de ese nodo. El kubelet usa el 
            tiempo de ejecuci√≥n de contenedores (container runtime) para iniciar el pod y monitoriza su ciclo de vida, 
            incluyendo pruebas de disponibilidad (readiness) y vitalidad (liveness), e informa al kube-apiserver.
          </p>
          
          <h4>Containerd</h4>
          <p>
            El mundo de Kubernetes ofrece varias opciones para tiempos de ejecuci√≥n de contenedores. Pero la 
            distribuci√≥n de Linux que GKE usa para sus nodos lanza contenedores usando <strong>Containerd</strong>, 
            el componente de tiempo de ejecuci√≥n de Docker.
          </p>
          
          <h4>kube-proxy</h4>
          <p>
            El trabajo de kube-proxy es mantener la <strong>conectividad de red entre los pods</strong> en el cl√∫ster.
          </p>
        </div>
      </section>

      <!-- Section 5: Conceptos de GKE -->
      <section id="conceptos-gke" class="content-section">
        <h2 class="section-title">üöÄ Conceptos de GKE</h2>
        
        <div class="content-card">
          <h3>De Kubernetes Manual a GKE</h3>
          <p>
            <code>kubeadm</code> puede automatizar gran parte de la configuraci√≥n inicial de un cl√∫ster. Pero si un 
            nodo falla o necesita mantenimiento, un administrador humano tiene que responder manualmente.
          </p>
          <p>
            <strong>GKE</strong> gestiona todos los componentes del plano de control por ti. Todav√≠a expone una 
            direcci√≥n IP a la que enviamos todas nuestras solicitudes de API de Kubernetes, pero GKE asume la 
            responsabilidad de aprovisionar y gestionar toda la infraestructura del plano de control detr√°s de ella. 
            Tambi√©n abstrae el tener un plano de control separado.
          </p>
          <p>
            En cualquier entorno de Kubernetes, los nodos son creados externamente por administradores del cl√∫ster, 
            no por Kubernetes en s√≠. GKE <strong>automatiza este proceso</strong> por ti. Lanza instancias de m√°quinas 
            virtuales de Compute Engine y las registra como nodos. Pagas por hora de vida de tus nodos (sin contar el 
            plano de control).
          </p>
        </div>
        
        <div class="content-card">
          <h3>Modos de Operaci√≥n: Autopilot vs Standard</h3>
          <p>GKE est√° disponible en dos modos de operaci√≥n:</p>
          <ul>
            <li>
              <strong>Autopilot:</strong> es un modo de operaci√≥n en GKE que gestiona toda la infraestructura del 
              cl√∫ster, incluyendo el plano de control, los grupos de nodos (node pools) y los nodos. Al gestionar todo 
              el cl√∫ster, Google monitoriza y gestiona todos los aspectos operativos, incluyendo el plano de control, 
              los nodos de trabajo y los componentes principales del sistema Kubernetes, asegurando que tus cargas de 
              trabajo siempre tengan un lugar donde ejecutarse. <em>Recomendado por Google</em> a menos que necesites 
              control granular.
            </li>
            <li>
              <strong>Standard:</strong> tiene toda la misma funcionalidad que Autopilot, pero t√∫ eres responsable de 
              la configuraci√≥n, gesti√≥n y optimizaci√≥n del cl√∫ster seg√∫n tus requisitos. M√°s control, m√°s responsabilidad.
            </li>
          </ul>
          <div class="tip-box">
            <strong>üí° Consejo de Google Cloud:</strong> A menos que tengas una raz√≥n espec√≠fica para necesitar el 
            nivel de control de configuraci√≥n que ofrece Standard, siempre deber√≠as usar el modo Autopilot.
          </div>
        </div>

        <div class="content-card">
          <h3>Node Pools</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch08.png" alt="Node Pools" loading="lazy">
          </div>

          <p>
            Un <strong>node pool</strong> es un subconjunto de nodos con configuraci√≥n id√©ntica (tipo de CPU, memoria, GPUs).
          </p>
          <ul>
            <li>Permiten ejecutar cargas de trabajo en el hardware adecuado mediante etiquetas.</li>
            <li>Soportan actualizaciones autom√°ticas, auto-repair y autoescalado.</li>
            <li>Por defecto, un cl√∫ster se crea con un node pool de 3 nodos.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Cl√∫steres Regionales</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch09.png" alt="Cl√∫steres Regionales" loading="lazy">
          </div>

          <p>
            Los <strong>cl√∫steres regionales</strong> distribuyen el plano de control y los nodos en m√∫ltiples zonas 
            de una regi√≥n, garantizando alta disponibilidad.
          </p>
          <ul>
            <li>Un √∫nico punto final de API para todo el cl√∫ster.</li>
            <li>La disponibilidad se mantiene incluso si una zona falla.</li>
            <li>El n√∫mero de nodos debe ser igual en todas las zonas.</li>
          </ul>
        </div>
      </section>

      <!-- Section 6: Gesti√≥n de Objetos -->
      <section id="gestion-objetos" class="content-section">
        <h2 class="section-title">üìã Gesti√≥n de Objetos en Kubernetes</h2>
        
        <div class="content-card">
          <h3>Modelo de Objetos de Kubernetes</h3>
          <p>
            Cada cosa que Kubernetes gestiona est√° representada por un <strong>objeto</strong>, y puedes ver y cambiar 
            estos objetos, sus atributos y su estado. Un objeto de Kubernetes se define como una entidad persistente 
            que representa el estado de algo que se ejecuta en un cl√∫ster, su estado deseado y su estado actual.
          </p>
          <p>
            Los objetos representan aplicaciones en contenedores, los recursos disponibles para ellas y las pol√≠ticas 
            que afectan su comportamiento.
          </p>
          
          <h4>Elementos importantes de los objetos</h4>
          <ul>
            <li>
              <strong>Object spec:</strong> para cada objeto que quieras crear, defines el estado deseado proporcionando 
              las caracter√≠sticas que buscas.
            </li>
            <li>
              <strong>Object status:</strong> es simplemente el estado actual del objeto proporcionado por el plano de 
              control de Kubernetes.
            </li>
          </ul>
          
          <p>
            Cada objeto es de un cierto tipo o 'Kind' (Tipo) como los llama Kubernetes. Los <strong>Pods</strong> son 
            el bloque de construcci√≥n b√°sico del modelo est√°ndar de Kubernetes, y son el objeto de Kubernetes 
            desplegable m√°s peque√±o.
          </p>
          
          <div class="tip-box">
            <strong>El principio de gesti√≥n declarativa:</strong> Kubernetes espera que le digas cu√°l quieres que sea 
            el estado de los objetos bajo su gesti√≥n, y trabajar√° para llevar ese estado a la realidad y mantenerlo all√≠.
          </div>
        </div>

        <div class="content-card">
          <h3>Manifiestos YAML</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch10.png" alt="Manifiestos YAML" loading="lazy">
          </div>

          <p>
            Kubernetes gestiona objetos declarativos definidos mediante archivos de manifiesto. Los objetos se definen 
            con <strong>manifest files</strong> escritos en YAML o JSON (YAML suele ser preferido por su legibilidad).
          </p>
          <p>Cada manifiesto declara el <strong>estado deseado</strong> del objeto. Campos obligatorios en un YAML:</p>
          <ul>
            <li><strong>apiVersion:</strong> versi√≥n de la API usada para crear el objeto.</li>
            <li><strong>kind:</strong> tipo de objeto (Pod, Deployment, Service, etc.).</li>
            <li><strong>metadata:</strong> nombre, UID, y namespace (opcional).</li>
            <li><strong>spec:</strong> configuraci√≥n deseada del objeto.</li>
          </ul>
          <div class="tip-box">
            <strong>üí° Buena pr√°ctica:</strong> Es una buena pr√°ctica incluir varios objetos relacionados en un mismo 
            archivo YAML. Los manifiestos deben guardarse en <strong>repositorios con control de versiones</strong>, 
            ya que esto facilita revertir cambios y reconstruir cl√∫steres si es necesario.
          </div>
        </div>

        <div class="content-card">
          <h3>Nombres, UID y Etiquetas</h3>
          <p>Cada objeto tiene un <strong>nombre √∫nico</strong> y un <strong>identificador √∫nico (UID)</strong> que lo distinguen dentro del cl√∫ster.</p>
          
          <h4>Nombres</h4>
          <ul>
            <li>Cada objeto tiene un nombre √∫nico <strong>dentro de su namespace</strong> (metadata nombre).</li>
            <li>Solo se permiten letras, n√∫meros, guiones y puntos, hasta 253 caracteres.</li>
            <li>Si un objeto se elimina, su nombre puede reutilizarse.</li>
          </ul>
          
          <h4>UID</h4>
          <p>Todos los objetos reciben un <strong>UID</strong> √∫nico que no cambia ni se repite en la vida del cl√∫ster.</p>
          
          <h4>Labels (Etiquetas)</h4>
          <p>Los objetos pueden tener <strong>labels</strong>, que son pares clave-valor usados para identificar, organizar y seleccionar recursos.</p>
          <ul>
            <li>Ejemplos: <code>app=nginx</code>, <code>env=prod</code>, <code>tier=backend</code>.</li>
            <li>Las etiquetas permiten seleccionar objetos mediante <strong>label selectors</strong>:
              <ul>
                <li>Con un valor espec√≠fico</li>
                <li>Sin un valor espec√≠fico</li>
                <li>Con un valor dentro de un conjunto</li>
              </ul>
            </li>
          </ul>
          <p>Ejemplo con kubectl para listar pods con una etiqueta espec√≠fica:</p>
          <pre><code>kubectl get pods -l app=nginx</code></pre>
        </div>

        <div class="content-card">
          <h3>Pods y Controladores</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch06.png" alt="Arquitectura de Pods" loading="lazy">
          </div>

          <p>
            Los <strong>Pods</strong> son el bloque de construcci√≥n b√°sico del modelo est√°ndar de Kubernetes y el 
            objeto desplegable m√°s peque√±o. Un Pod encarna el entorno donde viven los contenedores y ese entorno 
            puede acomodar uno o m√°s contenedores.
          </p>
          <ul>
            <li>Cada contenedor dentro de un Pod comparte el <strong>namespace de red</strong>, incluyendo la direcci√≥n IP y los puertos de red.</li>
            <li>Los contenedores dentro del mismo Pod pueden comunicarse a trav√©s de <code>localhost 127.0.0.1</code>.</li>
            <li>Un Pod tambi√©n puede especificar un conjunto de <strong>vol√∫menes de almacenamiento</strong> para ser compartidos entre sus contenedores.</li>
            <li>Los Pods <strong>no se auto-reparan (self-healing)</strong>.</li>
          </ul>
          
          <h4>Pods vs Controllers</h4>
          <p>
            Crear manualmente varios Pods (por ejemplo, 3 nginx) funciona para escalas peque√±as, pero no es pr√°ctico ni seguro:
          </p>
          <ul>
            <li>Los Pods son <strong>ef√≠meros</strong> y no se auto-reparan.</li>
            <li>Gestionar decenas o cientos de Pods con YAML individuales es ineficiente.</li>
          </ul>
          <p>
            En lugar de eso, Kubernetes utiliza <strong>objetos controladores</strong>, cuya funci√≥n es gestionar el estado deseado.
          </p>
          
          <h4>Tipos de Controladores</h4>
          <ul>
            <li>
              <strong>ReplicaSet:</strong> Asegura que una poblaci√≥n de Pods, todos id√©nticos entre s√≠, est√©n ejecut√°ndose al mismo tiempo.
            </li>
            <li>
              <strong>Deployment:</strong> Gestiona ReplicaSets y permite actualizaciones <strong>declarativas</strong> sobre Pods. 
              Los Deployments gestionan sus propios ReplicaSets para lograr el estado deseado, por lo que normalmente trabajar√°s 
              directamente con Deployments. Permiten crear Pods, actualizarlos, realizar rollbacks, escalarlos y usar ReplicaSets 
              autom√°ticamente cuando se necesite.
              <ul>
                <li>Durante un <em>rolling update</em>, el Deployment crea un segundo ReplicaSet, aumenta gradualmente los Pods 
                del nuevo ReplicaSet y disminuye los Pods del ReplicaSet inicial.</li>
              </ul>
            </li>
            <li>
              <strong>Replication Controller:</strong> Versi√≥n m√°s antigua que ofrece un rol similar. Su uso <strong>ya no es recomendado</strong>, 
              ya que los Deployments proporcionan una capa superior m√°s flexible y moderna.
            </li>
            <li>
              <strong>StatefulSet:</strong> Si necesitas ejecutar aplicaciones que <strong>mantienen estado local</strong>. Similar a un Deployment 
              en que los pods usan el mismo container spec, pero los Pods tienen <strong>identidades persistentes y √∫nicas</strong>, conservan 
              identidad de red estable y pueden usar almacenamiento persistente asociado a cada Pod.
            </li>
            <li>
              <strong>DaemonSet:</strong> Asegura que ciertos Pods se ejecuten en <strong>todos</strong> los nodos del cl√∫ster, o un subconjunto 
              espec√≠fico de nodos. Si se agregan nuevos nodos, el DaemonSet crea autom√°ticamente los Pods necesarios all√≠. Uso com√∫n: ejecutar 
              agentes como <strong>fluentd</strong> o recolectores de logs en todos los nodos.
            </li>
            <li>
              <strong>Job y CronJob:</strong>
              <ul>
                <li>Un <strong>Job</strong> crea uno o m√°s Pods para ejecutar una <strong>tarea puntual</strong>. Cuando la tarea termina, 
                el Job finaliza los Pods.</li>
                <li>Un <strong>CronJob</strong> ejecuta Jobs siguiendo una <strong>programaci√≥n basada en tiempo</strong>, como tareas cron tradicionales.</li>
              </ul>
            </li>
          </ul>
          
          <h4>¬øC√≥mo trabaja un Deployment?</h4>
          <ul>
            <li>El scheduler crea Pods y notifica cambios al API server.</li>
            <li>El Deployment controller monitoriza continuamente: si un Pod falla, detecta el cambio en el estado actual y crea un nuevo Pod para restaurar el estado deseado.</li>
            <li>Un Deployment permite especificar: n√∫mero de r√©plicas, especificaci√≥n de los Pods (containers, puertos, vol√∫menes) y pol√≠ticas de actualizaci√≥n.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Recursos del Pod y uso eficiente del cl√∫ster</h3>
          <p>
            Para garantizar que los contenedores funcionen correctamente, se pueden definir <strong>requests</strong> y 
            <strong>limits</strong> de recursos.
          </p>
          <ul>
            <li>Recursos m√°s comunes: <strong>CPU y memoria (RAM)</strong>.</li>
            <li><strong>Requests</strong> garantizan que el Pod tenga lo m√≠nimo necesario.</li>
            <li><strong>Limits</strong> evitan que una aplicaci√≥n consuma m√°s recursos de los permitidos.</li>
          </ul>
          <p>
            Esto previene situaciones como:
          </p>
          <ul>
            <li>Un nodo qued√°ndose sin memoria o CPU.</li>
            <li>Equipos subiendo r√©plicas innecesarias.</li>
            <li>Aplicaciones mal configuradas consumiendo el 100% del CPU.</li>
          </ul>
        </div>

        <div class="content-card">
          <h3>Namespaces</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch11.png" alt="Namespaces en Kubernetes" loading="lazy">
          </div>

          <p>
            Los <strong>namespaces</strong> permiten dividir un cl√∫ster f√≠sico en m√∫ltiples entornos l√≥gicos.
          </p>
          <ul>
            <li>Proveen un √°mbito de nombres para Pods, Deployments y otros recursos.</li>
            <li>Puedes crear objetos con el mismo nombre siempre que est√©n en namespaces distintos.</li>
            <li>Facilitan la organizaci√≥n, control de acceso (RBAC) y pruebas aisladas.</li>
          </ul>
          
          <h4>Usos t√≠picos de namespaces</h4>
          <ul>
            <li>Separar entornos: <code>test</code>, <code>stage</code>, <code>prod</code>.</li>
            <li>Evitar colisiones de nombres.</li>
            <li>Implementar <strong>resource quotas</strong>, que limitan el consumo de recursos por namespace.</li>
            <li>Crear despliegues temporales sin interferir con los existentes.</li>
          </ul>
          
          <h4>Namespaces iniciales del cl√∫ster</h4>
          <ul>
            <li><strong>default:</strong> donde van los recursos que no especifican un namespace.</li>
            <li><strong>kube-system:</strong> contiene objetos internos de Kubernetes.</li>
            <li><strong>kube-public:</strong> accesible p√∫blicamente y √∫til para compartir informaci√≥n com√∫n en el cl√∫ster.</li>
          </ul>
          
          <div class="tip-box">
            <strong>üí° Buena pr√°ctica:</strong> Preferir aplicar el namespace desde la l√≠nea de comando 
            (ej. <code>-n test apply -f mypod.yaml</code>) en lugar de especificarlo en YAML. Esto mantiene los YAML 
            reutilizables en m√∫ltiples entornos. Incrustar el namespace en el YAML dificulta mantener instancias 
            independientes del mismo despliegue.
          </div>
        </div>

        <div class="content-card">
          <h3>Servicios en Kubernetes</h3>
          <p>
            Los <strong>Services</strong> proporcionan acceso balanceado y estable a un conjunto de Pods, ofreciendo 
            un punto de entrada consistente aunque los Pods cambien de IP o se reinicien.
          </p>
          
          <h4>Tipos de Services</h4>
          
          <p><strong>ClusterIP</strong></p>
          <p>
            Expone el servicio en una IP accesible <strong>solo dentro del cl√∫ster</strong>. Es el tipo <strong>por 
            defecto</strong>. Uso t√≠pico: comunicaci√≥n interna entre microservicios.
          </p>
          
          <p><strong>NodePort</strong></p>
          <p>
            Expone el servicio en la IP de <strong>cada nodo</strong> del cl√∫ster, usando un puerto fijo. Permite 
            acceso externo v√≠a <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>. √ötil para pruebas o cuando no hay un 
            balanceador externo.
          </p>
          
          <p><strong>LoadBalancer</strong></p>
          <p>
            Expone el servicio <strong>externamente</strong> usando el balanceador del proveedor cloud. En GKE crea 
            un <strong>Network Load Balancer regional</strong>. Uso t√≠pico: servicios p√∫blicos que necesitan IP 
            externa y balanceo de red.
          </p>
          
          <h4>Nota sobre Ingress en GKE</h4>
          <p>
            Si necesitas balanceo global o capacidades HTTP(S) de capa 7 (rutas, TLS gestionado, reglas basadas en 
            host/path), utiliza un <strong>Ingress</strong>. En GKE, un Ingress se integra con el <strong>HTTP(S) 
            Load Balancer global</strong>, ofreciendo enrutamiento avanzado frente al LoadBalancer regional por defecto.
          </p>
        </div>
      </section>

      <!-- Section 7: Migrate for Anthos -->
      <section id="migrate-anthos" class="content-section">
        <h2 class="section-title">üîÑ Migrate for Anthos</h2>
        
        <div class="content-card">
          <h3>Modernizaci√≥n de Aplicaciones</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch12.png" alt="Migrate for Anthos Overview" loading="lazy">
          </div>

          <p>
            <strong>Migrate for Anthos</strong> mueve tus aplicaciones existentes hacia un entorno Kubernetes. 
            Lo mejor: <strong>el proceso es completamente automatizado</strong>.
          </p>
        </div>

        <div class="content-card">
          <h3>Flujo General del Proceso</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch13.png" alt="Pipeline de Migraci√≥n" loading="lazy">
          </div>

          <h4>1. Crear un pipeline de migraci√≥n</h4>
          <p>
            El primer paso consiste en permitir que <strong>Migrate for Compute Engine</strong> cree un pipeline 
            para transmitir o migrar datos desde entornos <em>on-premises</em> u otros proveedores de la nube hacia 
            Google Cloud.
          </p>
          
          <h4>2. Uso de Migrate for Compute Engine</h4>
          <p>Esta herramienta permite traer aplicaciones existentes hacia m√°quinas virtuales en Google Cloud.</p>
          
          <h4>3. Instalar Migrate for Anthos</h4>
          <ul>
            <li>Se instala en un <strong>cluster de procesamiento GKE</strong>.</li>
            <li>Est√° compuesto por m√∫ltiples recursos de Kubernetes.</li>
          </ul>
          
          <h4>4. Generaci√≥n de artefactos de despliegue</h4>
          <p>Migrate for Anthos genera artefactos como:</p>
          <ul>
            <li>Archivos de configuraci√≥n de Kubernetes</li>
            <li>Dockerfile</li>
          </ul>
          <p>Estos artefactos se usan para crear el <strong>VM wrapping container</strong> (contenedor que envuelve la VM).</p>
          
          <h4>5. Almacenamiento de artefactos</h4>
          <ul>
            <li>El contenedor resultante se almacena en <strong>Cloud Storage</strong>.</li>
            <li>Las im√°genes de contenedor se almacenan en <strong>Container Registry</strong>.</li>
          </ul>
          
          <h4>6. Despliegue en el cluster destino</h4>
          <p>
            Una vez generados los artefactos, se pueden aplicar directamente al cluster objetivo. Al aplicar la 
            configuraci√≥n generada, se crean todos los elementos de Kubernetes necesarios para ejecutar la aplicaci√≥n.
          </p>
        </div>

        <div class="content-card">
          <h3>Flujo de Migraci√≥n de una Aplicaci√≥n</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch14.png" alt="Flujo de Migraci√≥n Detallado" loading="lazy">
          </div>

          <p>Ahora que conoces la arquitectura general necesaria para una migraci√≥n, veamos qu√© ocurre paso a paso:</p>
          
          <ol>
            <li><strong>Crear el processing cluster:</strong> Lo primero es crear el cluster de procesamiento, donde ocurrir√° la conversi√≥n de la m√°quina virtual a contenedor.</li>
            <li><strong>Instalar los componentes de Migrate for Anthos:</strong> Estos componentes incluyen los recursos y controladores necesarios para analizar y convertir workloads.</li>
            <li><strong>A√±adir una fuente de migraci√≥n:</strong> Puedes migrar desde distintas plataformas, otras nubes u on-prem.</li>
            <li><strong>Crear un objeto de migraci√≥n:</strong> Debes crear un objeto Migration con detalles del origen, configuraci√≥n del workload y opciones de conversi√≥n. Al crear este objeto, se genera autom√°ticamente una plantilla de plan (plan template) en un archivo YAML.</li>
            <li><strong>Ajustar la plantilla (opcional):</strong> Puedes editar el YAML generado si necesitas personalizar configuraciones del contenedor, par√°metros del runtime, opciones de almacenamiento o configuraciones de red.</li>
            <li><strong>Generar los artefactos de migraci√≥n:</strong> Cuando el plan est√° listo, generas los artefactos: im√°genes de contenedor que representan tu aplicaci√≥n convertida desde la VM y archivos YAML necesarios para desplegar en Kubernetes.</li>
            <li><strong>Probar los artefactos generados:</strong> Antes del despliegue final, es necesario probarlo.</li>
            <li><strong>Desplegar en cl√∫steres de producci√≥n:</strong> Si las pruebas son exitosas, puedes usar los artefactos generados para desplegar la aplicaci√≥n en uno o varios clusters de producci√≥n utilizando kubectl o pipelines automatizados.</li>
          </ol>
        </div>

        <div class="content-card">
          <h3>Ejemplo Pr√°ctico: Migraci√≥n Paso a Paso</h3>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch15.png" alt="Configuraci√≥n del Cl√∫ster de Procesamiento" loading="lazy">
          </div>

          <h4>Paso 1: Configurar el cl√∫ster de procesamiento</h4><p>
            Crea un cl√∫ster GKE dedicado para procesar migraciones. Necesitas:
          </p>
          <ul>
            <li>Permisos adecuados para acceder a VMs origen.</li>
            <li>Reglas de firewall para comunicaci√≥n con las VMs.</li>
            <li>Suficiente capacidad de c√≥mputo para procesar la conversi√≥n.</li>
          </ul>
          
          <h4>Paso 2: Instalar migctl</h4><p>
            <code>migctl</code> es la CLI de Migrate for Anthos. Inst√°lala con:
          </p>
          <pre><code>gcloud components install migctl</code></pre>
          <p>
            Luego config√∫rala para usar tu cl√∫ster de procesamiento:
          </p>
          <pre><code>migctl setup install --gcp-project=[PROJECT_ID] --gcp-region=[REGION]</code></pre>
          
          <h4>Paso 3: Verificar el estado del cl√∫ster</h4><p>
            Comprueba que todos los componentes est√©n desplegados correctamente:
          </p>
          <pre><code>migctl doctor</code></pre>
          <p>
            Esto verifica conectividad, permisos y estado de los servicios necesarios.
          </p>
          
          <h4>Paso 4: Crear el Migration Plan</h4>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch16.png" alt="Creaci√≥n del Migration Plan" loading="lazy">
          </div>

          <p>
            Un <strong>Migration Plan</strong> describe qu√© VM migrar y c√≥mo:
          </p>
          <pre><code>migctl migration create my-migration --source my-vm-ce --type linux-system-container</code></pre>
          <p>
            Especifica el tipo de contenedor resultante: System container (contenedor con init) o Data container 
            (solo datos/aplicaci√≥n).
          </p>
          
          <h4>Paso 5: Generar artefactos</h4>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch17.png" alt="Generaci√≥n de Artefactos" loading="lazy">
          </div>

          <p>
            Migrate for Anthos analiza la VM y genera:
          </p>
          <ul>
            <li><strong>Dockerfile:</strong> contiene las instrucciones para construir la imagen.</li>
            <li><strong>Manifiestos de Kubernetes:</strong> Deployment, Service, ConfigMap, etc.</li>
            <li><strong>Imagen de contenedor:</strong> almacenada en Artifact Registry o Container Registry.</li>
          </ul>
          <pre><code>migctl migration generate-artifacts my-migration</code></pre>
          <p>
            Revisa y ajusta los artefactos generados seg√∫n necesites (por ejemplo, a√±adir health checks, ajustar recursos).
          </p>
          
          <h4>Paso 6: Desplegar en producci√≥n</h4>
          
          <div class="image-container">
            <img src="/DevSecOps/GoogleDevOpsSRE/kubernetes/arch18.png" alt="Despliegue en Producci√≥n" loading="lazy">
          </div>

          <p>
            Con los artefactos generados, despliega la aplicaci√≥n en tu cl√∫ster de producci√≥n:
          </p>
          <pre><code>kubectl apply -f deployment.yaml</code></pre>
          <p>
            Verifica que el Pod est√© corriendo y que la aplicaci√≥n funcione correctamente:
          </p>
          <pre><code>kubectl get pods
kubectl logs [POD_NAME]</code></pre>
          
          <div class="tip-box">
            <strong>üí° Beneficios:</strong> Al migrar a contenedores, obtienes portabilidad, escalado autom√°tico, 
            integraci√≥n con CI/CD, y la capacidad de modernizar gradualmente tu aplicaci√≥n sin reescribirla desde cero.
          </div>
        </div>
      </section>

      </div>
      <!-- End content-wrapper -->

      <!-- Flashcards Section -->
      <section class="flashcards-section">
        <h2 class="section-title">üéØ Flashcards de Estudio</h2>
        <p class="flashcards-description">Haz clic en cada tarjeta para revelar la respuesta</p>
        
        <div class="flashcards-grid">
          <!-- Flashcard 1 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°l es la diferencia principal entre contenedores y m√°quinas virtuales?</p>
              </div>
              <div class="flashcard-back">
                <p>Los contenedores abstraen solo el espacio de usuario sin virtualizar todo el sistema operativo, siendo m√°s ligeros y r√°pidos. Las VMs incluyen un sistema operativo completo y son m√°s pesadas.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 2 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© son los namespaces de Linux en el contexto de contenedores?</p>
              </div>
              <div class="flashcard-back">
                <p>Son una tecnolog√≠a que controla lo que una aplicaci√≥n puede ver, como identificadores de proceso, √°rboles de directorios y direcciones IP. No son lo mismo que los namespaces de Kubernetes.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 3 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© hacen los cgroups (control groups)?</p>
              </div>
              <div class="flashcard-back">
                <p>Limitan los recursos que una aplicaci√≥n puede usar, incluyendo CPU, memoria, ancho de banda de I/O y otros recursos del sistema.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 4 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© comandos principales tiene un Dockerfile y qu√© hace cada uno?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>FROM:</strong> crea la capa base; <strong>COPY:</strong> agrega archivos; <strong>RUN:</strong> ejecuta comandos de construcci√≥n; <strong>CMD:</strong> define el comando al iniciar el contenedor.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 5 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es la construcci√≥n multi-stage en Docker?</p>
              </div>
              <div class="flashcard-back">
                <p>Una pr√°ctica donde un contenedor se encarga de construir la aplicaci√≥n y otro contenedor recibe solo lo necesario para ejecutarla, evitando incluir herramientas de construcci√≥n innecesarias.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 6 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es Artifact Registry en GCP?</p>
              </div>
              <div class="flashcard-back">
                <p>Un servicio que almacena im√°genes de contenedor, paquetes de lenguaje y de sistema operativo, con integraci√≥n a IAM, KMS, Cloud Build y Container Analysis.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 7 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°les son los componentes principales del plano de control de Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>kube-apiserver</strong> (punto de entrada), <strong>etcd</strong> (base de datos), <strong>kube-scheduler</strong> (asignaci√≥n de pods), <strong>kube-controller-manager</strong> (mantiene estado deseado), <strong>cloud-controller-manager</strong> (integraci√≥n con proveedores).</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 8 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es el kubelet y cu√°l es su funci√≥n?</p>
              </div>
              <div class="flashcard-back">
                <p>Es el agente de Kubernetes en cada nodo. Cuando el kube-apiserver quiere iniciar un pod, se conecta al kubelet, que usa el container runtime para iniciarlo y monitoriza su ciclo de vida.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 9 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°l es la diferencia entre Autopilot y Standard en GKE?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>Autopilot:</strong> Google gestiona toda la infraestructura (recomendado). <strong>Standard:</strong> t√∫ eres responsable de configurar y optimizar el cl√∫ster.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 10 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es un Node Pool en GKE?</p>
              </div>
              <div class="flashcard-back">
                <p>Un subconjunto de nodos dentro de un cl√∫ster que comparten una configuraci√≥n id√©ntica (tipo de CPU, memoria, GPUs). Permite ejecutar cargas en el hardware adecuado mediante etiquetas.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 11 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© son los object spec y object status en Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>Object spec:</strong> el estado deseado que defines. <strong>Object status:</strong> el estado actual del objeto, proporcionado por el plano de control.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 12 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© campos son obligatorios en un manifiesto YAML de Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>apiVersion</strong> (versi√≥n de la API), <strong>kind</strong> (tipo de objeto), <strong>metadata</strong> (nombre, UID, namespace), y <strong>spec</strong> (configuraci√≥n deseada).</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 13 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© son los labels en Kubernetes y para qu√© sirven?</p>
              </div>
              <div class="flashcard-back">
                <p>Son pares clave-valor (ej: app=nginx, env=prod) usados para identificar, organizar y seleccionar recursos mediante label selectors.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 14 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es un Pod en Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p>El bloque de construcci√≥n b√°sico y el objeto desplegable m√°s peque√±o. Encarna el entorno donde viven uno o m√°s contenedores que comparten namespace de red y vol√∫menes.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 15 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°l es la diferencia entre un ReplicaSet y un Deployment?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>ReplicaSet:</strong> asegura una poblaci√≥n de Pods id√©nticos. <strong>Deployment:</strong> gestiona ReplicaSets para lograr actualizaciones declarativas, rollbacks y rolling updates.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 16 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°ndo usar√≠as un StatefulSet en lugar de un Deployment?</p>
              </div>
              <div class="flashcard-back">
                <p>Para aplicaciones que mantienen estado local y requieren identidades persistentes y √∫nicas, con identidad de red estable y almacenamiento persistente asociado a cada Pod.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 17 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es un DaemonSet y cu√°l es su caso de uso?</p>
              </div>
              <div class="flashcard-back">
                <p>Asegura que ciertos Pods se ejecuten en todos los nodos del cl√∫ster (o un subconjunto). Uso com√∫n: ejecutar agentes como fluentd o recolectores de logs en todos los nodos.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 18 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© son requests y limits en Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>Requests:</strong> recursos m√≠nimos garantizados que necesita un Pod. <strong>Limits:</strong> m√°ximo consumo permitido. Previenen que nodos se queden sin recursos.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 19 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øPara qu√© sirven los namespaces en Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p>Dividen un cl√∫ster f√≠sico en m√∫ltiples entornos l√≥gicos (test, stage, prod), facilitan organizaci√≥n, control de acceso (RBAC) y permiten implementar resource quotas.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 20 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°les son los namespaces iniciales de un cl√∫ster de Kubernetes?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>default:</strong> recursos sin namespace especificado; <strong>kube-system:</strong> objetos internos de Kubernetes; <strong>kube-public:</strong> accesible p√∫blicamente.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 21 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°l es la diferencia entre ClusterIP, NodePort y LoadBalancer?</p>
              </div>
              <div class="flashcard-back">
                <p><strong>ClusterIP:</strong> solo interno (defecto); <strong>NodePort:</strong> expone en cada nodo; <strong>LoadBalancer:</strong> expone externamente con balanceador del proveedor cloud.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 22 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es un Ingress en GKE y cu√°ndo lo usar√≠as?</p>
              </div>
              <div class="flashcard-back">
                <p>Proporciona balanceo HTTP(S) global de capa 7 con capacidades avanzadas (rutas, TLS gestionado, reglas basadas en host/path). Se integra con el HTTP(S) Load Balancer global.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 23 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© hace Migrate for Anthos?</p>
              </div>
              <div class="flashcard-back">
                <p>Mueve aplicaciones existentes desde VMs (on-premise u otras nubes) hacia contenedores en Kubernetes de forma completamente automatizada.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 24 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°les son los 6 pasos principales del flujo general de Migrate for Anthos?</p>
              </div>
              <div class="flashcard-back">
                <p>1) Crear pipeline de migraci√≥n, 2) Usar Migrate for Compute Engine, 3) Instalar Migrate for Anthos, 4) Generar artefactos, 5) Almacenar en Cloud Storage/Registry, 6) Desplegar en cluster destino.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 25 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© artefactos genera Migrate for Anthos?</p>
              </div>
              <div class="flashcard-back">
                <p>Archivos de configuraci√≥n de Kubernetes (YAMLs), Dockerfile, y el VM wrapping container (imagen de contenedor que envuelve la VM).</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 26 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© es Cloud Build en GCP?</p>
              </div>
              <div class="flashcard-back">
                <p>Un servicio gestionado que automatiza la construcci√≥n de contenedores, integrado con IAM. Recupera c√≥digo de repositorios, ejecuta pasos de build en contenedores Docker y entrega im√°genes a GKE, App Engine o Cloud Functions.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 27 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øCu√°ndo elegir√≠as Compute Engine sobre GKE?</p>
              </div>
              <div class="flashcard-back">
                <p>Para migraci√≥n desde servidores f√≠sicos, aplicaciones en VMs tradicionales, o cuando necesitas arquitecturas que no encajan en opciones serverless o gestionadas.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 28 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© ventajas ofrece Cloud Run?</p>
              </div>
              <div class="flashcard-back">
                <p>Ejecuta contenedores stateless de forma serverless, escala autom√°ticamente desde 0, pagas solo por uso (100ms de granularidad), sin gesti√≥n de servidores.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 29 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øQu√© hace el kube-scheduler?</p>
              </div>
              <div class="flashcard-back">
                <p>Es responsable de programar (scheduling) los pods en los nodos. Elige un nodo y escribe su nombre en el objeto pod, obedeciendo restricciones basadas en hardware, software y pol√≠ticas.</p>
              </div>
            </div>
          </div>

          <!-- Flashcard 30 -->
          <div class="flashcard">
            <div class="flashcard-inner">
              <div class="flashcard-front">
                <p>¬øPor qu√© es importante ordenar las instrucciones en un Dockerfile?</p>
              </div>
              <div class="flashcard-back">
                <p>Para optimizar la reutilizaci√≥n de capas en futuras construcciones. Se recomienda ordenar desde las capas menos propensas a cambiar hasta las m√°s propensas a cambiar.</p>
              </div>
            </div>
          </div>

        </div>
      </section>

      <!-- Progress Section -->
      <div class="progress-section">
        <h3 class="progress-title">Tu Progreso en Kubernetes Engine Foundations</h3>
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: 0%">
            <span class="progress-text">0% completado</span>
          </div>
        </div>
        <p class="progress-description">Completa las secciones para avanzar en tu aprendizaje</p>
      </div>

      </div>
      <!-- End content-section -->

    </div>
    <!-- End gcp-container -->

  </div>
  <!-- End page-wrapper -->

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* Page Layout with Sidebar */
    .page-wrapper {
      display: flex;
      justify-content: center;
      gap: 24px;
      min-height: 100vh;
    }

    /* Sidebar Navigation */
    .sidebar {
      position: fixed;
      left: calc(50% - 600px - 300px);
      top: 80px;
      width: 280px;
      height: calc(100vh - 140px);
      background: rgba(20, 20, 40, 0.95);
      backdrop-filter: blur(10px);
      border-right: 1px solid rgba(122, 107, 255, 0.3);
      border-radius: 12px;
      padding: 20px 0;
      overflow-y: auto;
      z-index: 100;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .sidebar::-webkit-scrollbar {
      display: none;
    }

    .sidebar-header {
      padding: 0 24px 20px;
      border-bottom: 2px solid rgba(122, 107, 255, 0.3);
      margin-bottom: 16px;
    }

    .sidebar-header h3 {
      font-size: 1.3rem;
      color: #a5b4fc;
      font-weight: 700;
    }

    .sidebar-nav {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 0 16px;
    }

    .modules-nav {
      margin-bottom: 12px;
    }

    .module-item {
      position: relative;
      margin-bottom: 4px;
    }

    .nav-link {
      color: rgba(255, 255, 255, 0.7);
      text-decoration: none;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .module-link {
      font-weight: 500;
      padding: 12px 14px;
      border-radius: 8px;
      border-left: 3px solid transparent;
      font-size: 0.9rem;
    }

    .module-link:hover {
      background: rgba(122, 107, 255, 0.15);
      color: #a5b4fc;
      border-left-color: #7a6bff;
      transform: translateX(4px);
    }

    .module-link.active {
      background: rgba(122, 107, 255, 0.25);
      color: #c7d2fe;
      border-left-color: #7a6bff;
      font-weight: 600;
    }

    .module-icon {
      font-size: 1.1rem;
      flex-shrink: 0;
    }

    .module-text {
      flex: 1;
    }

    .submenu {
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 0.4s ease, opacity 0.3s ease, padding 0.3s ease;
      padding: 0 0 0 40px;
      margin: 0;
    }

    .module-item:hover .submenu,
    .module-item.expanded .submenu {
      max-height: 500px;
      opacity: 1;
      padding: 8px 0 8px 40px;
    }

    .submenu-link {
      display: block;
      padding: 8px 14px;
      color: rgba(255, 255, 255, 0.6);
      text-decoration: none;
      font-size: 0.85rem;
      border-radius: 6px;
      border-left: 2px solid transparent;
      margin-bottom: 2px;
      transition: all 0.2s ease;
    }

    .submenu-link:hover {
      color: #a5b4fc;
      background: rgba(122, 107, 255, 0.1);
      border-left-color: rgba(122, 107, 255, 0.5);
      transform: translateX(3px);
    }

    .submenu-link.active {
      color: #c7d2fe;
      background: rgba(122, 107, 255, 0.15);
      border-left-color: #7a6bff;
      font-weight: 500;
    }

    .sidebar-footer {
      padding: 20px 24px;
      margin-top: 20px;
      border-top: 1px solid rgba(122, 107, 255, 0.2);
    }

    .back-link {
      display: block;
      padding: 12px 16px;
      color: #a5b4fc;
      text-decoration: none;
      background: rgba(122, 107, 255, 0.1);
      border: 1px solid rgba(122, 107, 255, 0.3);
      border-radius: 8px;
      text-align: center;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: rgba(122, 107, 255, 0.2);
      transform: translateX(-4px);
    }

    .gcp-container {
      flex: 1;
      margin-left: 0;
      max-width: 1200px;
      padding: 32px 48px 80px 48px;
      color: rgba(255, 255, 255, 0.92);
    }

    .navigation-back a:hover {
      background: rgba(122, 107, 255, 0.2);
      border-color: rgba(122, 107, 255, 0.5);
      transform: translateX(-4px);
    }

    .gcp-hero {
      text-align: center;
      padding: 60px 24px;
      margin-bottom: 48px;
      background: linear-gradient(135deg, rgba(122, 107, 255, 0.15) 0%, rgba(165, 180, 252, 0.08) 100%);
      border-radius: 24px;
      border: 1px solid rgba(122, 107, 255, 0.3);
    }

    .gcp-title {
      font-size: 3rem;
      font-weight: 700;
      color: #a5b4fc;
      margin-bottom: 12px;
      text-shadow: 0 2px 20px rgba(122, 107, 255, 0.3);
    }

    .gcp-subtitle-main {
      font-size: 2rem;
      font-weight: 600;
      color: #7a6bff;
      margin-bottom: 16px;
    }

    .gcp-description {
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.7);
      max-width: 700px;
      margin: 0 auto;
    }

    .content-wrapper {
      max-width: 1000px;
      margin: 0 auto;
    }

    .content-section {
      margin-bottom: 64px;
    }

    .section-title {
      font-size: 2.2rem;
      color: #c7d2fe;
      margin-bottom: 32px;
      padding-bottom: 16px;
      border-bottom: 2px solid rgba(122, 107, 255, 0.3);
    }

    .content-card {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 32px;
      margin-bottom: 24px;
      transition: all 0.3s ease;
    }

    .content-card:hover {
      background: rgba(255, 255, 255, 0.04);
      border-color: rgba(122, 107, 255, 0.3);
      box-shadow: 0 4px 20px rgba(122, 107, 255, 0.1);
    }

    .content-card h3 {
      color: #a5b4fc;
      font-size: 1.6rem;
      margin-bottom: 16px;
    }

    .content-card h4 {
      color: #c7d2fe;
      font-size: 1.3rem;
      margin: 24px 0 12px 0;
    }

    .content-card p {
      line-height: 1.8;
      margin-bottom: 16px;
      color: rgba(255, 255, 255, 0.85);
    }

    .content-card ul, .content-card ol {
      margin: 16px 0 16px 24px;
      line-height: 1.8;
    }

    .content-card li {
      margin-bottom: 10px;
      color: rgba(255, 255, 255, 0.8);
    }

    .content-card code {
      background: rgba(122, 107, 255, 0.15);
      color: #a5b4fc;
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .image-container {
      margin: 24px 0;
      text-align: center;
    }

    .image-container img {
      max-width: 100%;
      height: auto;
      border-radius: 12px;
      border: 1px solid rgba(122, 107, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .tip-box {
      background: rgba(122, 107, 255, 0.1);
      border-left: 4px solid #7a6bff;
      padding: 16px 20px;
      border-radius: 8px;
      margin: 20px 0;
    }

    .tip-box strong {
      color: #a5b4fc;
    }

    pre {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(122, 107, 255, 0.3);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
      margin: 16px 0;
    }

    pre code {
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      color: #c7d2fe;
      line-height: 1.6;
    }

    code {
      background: rgba(122, 107, 255, 0.15);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #a5b4fc;
    }

    h4 {
      color: #c7d2fe;
      font-size: 1.2rem;
      margin-top: 28px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .progress-section {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 32px;
      text-align: center;
      margin-top: 60px;
    }

    .progress-title {
      font-size: 1.5rem;
      color: #c7d2fe;
      margin-bottom: 20px;
    }

    .progress-bar-container {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      height: 40px;
      overflow: hidden;
      margin-bottom: 16px;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #7a6bff, #a5b4fc);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: width 0.5s ease;
    }

    .progress-text {
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .progress-description {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.6);
    }

    /* Flashcards Section */
    .flashcards-section {
      margin: 60px 0;
      padding: 40px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(122, 107, 255, 0.2);
      border-radius: 16px;
    }

    .flashcards-description {
      text-align: center;
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 32px;
    }

    .flashcards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 24px;
      margin-top: 32px;
    }

    .flashcard {
      height: 200px;
      perspective: 1000px;
      cursor: pointer;
    }

    .flashcard-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    .flashcard.flipped .flashcard-inner {
      transform: rotateY(180deg);
    }

    .flashcard-front,
    .flashcard-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .flashcard-front {
      background: linear-gradient(135deg, rgba(122, 107, 255, 0.2) 0%, rgba(165, 180, 252, 0.1) 100%);
      border: 1px solid rgba(122, 107, 255, 0.3);
      color: #c7d2fe;
    }

    .flashcard-front p {
      font-size: 1rem;
      font-weight: 500;
      text-align: center;
      line-height: 1.6;
    }

    .flashcard-back {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(59, 130, 246, 0.15) 100%);
      border: 1px solid rgba(34, 197, 94, 0.3);
      color: #d1fae5;
      transform: rotateY(180deg);
    }

    .flashcard-back p {
      font-size: 0.95rem;
      text-align: center;
      line-height: 1.6;
    }

    .flashcard-back strong {
      color: #86efac;
    }

    .flashcard:hover .flashcard-front {
      box-shadow: 0 6px 30px rgba(122, 107, 255, 0.4);
      border-color: rgba(122, 107, 255, 0.5);
    }

    .flashcard:hover .flashcard-back {
      box-shadow: 0 6px 30px rgba(34, 197, 94, 0.4);
    }

    @media (max-width: 1024px) {
      .sidebar {
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .gcp-container {
        margin-left: 0;
        padding: 24px 20px 60px;
      }
    }

    @media (max-width: 768px) {
      .gcp-title {
        font-size: 2rem;
      }

      .gcp-subtitle-main {
        font-size: 1.5rem;
      }

      .section-title {
        font-size: 1.8rem;
      }

      .content-card {
        padding: 20px;
      }

      .sidebar {
        width: 100%;
      }

      .flashcards-grid {
        grid-template-columns: 1fr;
      }

      .flashcard {
        height: 180px;
      }

      .flashcard-front p,
      .flashcard-back p {
        font-size: 0.9rem;
      }
    }
  </style>

  <script>
    // Track progress in localStorage
    document.addEventListener('DOMContentLoaded', () => {
      const completedSections = JSON.parse(localStorage.getItem('k8s-sections-completed') || '[]');
      const totalSections = 7;
      const percentage = Math.round((completedSections.length / totalSections) * 100);
      
      const progressBar = document.querySelector('.progress-bar');
      const progressText = document.querySelector('.progress-text');
      
      if (progressBar && progressText) {
        progressBar.style.width = `${percentage}%`;
        progressText.textContent = `${percentage}% completado`;
      }

      // Sidebar Navigation Active State
      const sections = document.querySelectorAll('.content-section');
      const submenuLinks = document.querySelectorAll('.submenu-link');

      // Intersection Observer for active section highlighting in submenu
      const observerOptions = {
        root: null,
        rootMargin: '-100px 0px -70% 0px',
        threshold: 0
      };

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const id = entry.target.getAttribute('id');
            submenuLinks.forEach(link => {
              link.classList.remove('active');
              const href = link.getAttribute('href');
              if (href && href.includes(`#${id}`)) {
                link.classList.add('active');
              }
            });
          }
        });
      }, observerOptions);

      sections.forEach(section => observer.observe(section));

      // Smooth scroll for internal submenu links
      submenuLinks.forEach(link => {
        link.addEventListener('click', (e) => {
          const href = link.getAttribute('href');
          if (href && href.includes('#')) {
            const hashIndex = href.indexOf('#');
            const hash = href.substring(hashIndex + 1);
            const targetSection = document.getElementById(hash);
            
            // Only prevent default and smooth scroll if target is on current page
            if (targetSection) {
              e.preventDefault();
              targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        });
      });

      // Flashcards flip functionality
      const flashcards = document.querySelectorAll('.flashcard');
      
      flashcards.forEach(card => {
        card.addEventListener('click', () => {
          card.classList.toggle('flipped');
        });
      });
    });
  </script>
</BaseLayout>

