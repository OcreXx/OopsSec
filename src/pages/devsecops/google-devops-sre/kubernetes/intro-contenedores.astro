---
import BaseLayout from "../../../../../layouts/BaseLayout.astro";
import Contenido from "../../../../../components/Contenido.astro";
import Sidebar from "../../../../../components/Sidebar.astro";
import { SidebarItem } from "../../../../../components/Sidebar";
const sidebarItems: SidebarItem[] = [
  {
    title: "Introducción a Contenedores",
    children: [
      { title: "Evolución hacia la virtualización", slug: "#evolucion" },
      { title: "Contenedores e Imágenes", slug: "#contenedores-imagenes" },
      { title: "Capas en un Dockerfile", slug: "#dockerfile" },
      { title: "Buenas prácticas", slug: "#buenas-practicas" },
      { title: "Uso de imágenes", slug: "#uso-imagenes" },
    ],
  },
];
---

<BaseLayout
  title="Introducción a Contenedores - GKE Foundations"
  description="Aprende los conceptos fundamentales de los contenedores, desde la virtualización hasta las imágenes de Docker y las mejores prácticas."
>
  <div class="page-wrapper">
    <Sidebar
      items={sidebarItems}
      basePath="/devsecops/google-devops-sre/kubernetes-engine-fundamentals"
      backPath="/devsecops/google-devops-sre/kubernetes-engine-fundamentals"
      moduleName="GKE Foundations"
    />
    <main class="gcp-container">
      <Contenido
        title="Introducción a Contenedores"
        subtitle="Conceptos básicos de contenedores, imágenes y su evolución."
      >
        <div id="evolucion" class="content-card">
          <h3>Evolución hacia la virtualización</h3>
          <p>
            Antes, cada aplicación se ejecutaba en su propio servidor físico, lo
            que hacía el despliegue lento, costoso, con mucho desperdicio de
            recursos y poca portabilidad.
          </p>
          <p>
            La virtualización introdujo el hipervisor, permitiendo crear varias
            máquinas virtuales sobre un mismo hardware. Esto aceleró los
            despliegues y aprovechó mejor los recursos, pero las VMs seguían
            siendo pesadas: cada una incluye su propio sistema operativo, tarda
            en arrancar y no se mueve fácilmente entre distintos hipervisores.
          </p>
          <p>
            Ejecutar varias apps dentro de una misma VM tampoco funcionaba bien:
            no había aislamiento, podían estorbarse con recursos o dependencias,
            y actualizar una podía romper otra. La alternativa de usar{" "}
            <strong>una VM por aplicación</strong> resolvió el aislamiento, pero
            escalaba muy mal porque cada VM duplicaba un sistema operativo
            completo.
          </p>
          <div class="image-container">
            <img
              src="/DevSecOps/GoogleDevOpsSRE/arch01.png"
              alt="Evolución de la virtualización"
              loading="lazy"
            />
          </div>
          <p>
            Una forma más eficiente de resolver los problemas de dependencias es
            abstraer solo el espacio de usuario, sin virtualizar toda la máquina
            ni el sistema operativo. Esto permite empaquetar la aplicación junto
            con sus dependencias sin incluir un sistema operativo completo. A
            esta técnica se le conoce como contenedores, y representa un avance
            clave frente a las VMs al ser más ligeros, rápidos y portables.
          </p>
        </div>

        <div id="contenedores-imagenes" class="content-card">
          <h3>Contenedores e Imágenes</h3>
          <div class="image-container">
            <img
              src="/DevSecOps/GoogleDevOpsSRE/arch02.png"
              alt="Contenedores e Imágenes"
              loading="lazy"
            />
          </div>
          <p>
            Los contenedores no son una característica primitiva de Linux; su
            capacidad para <strong>aislar cargas de trabajo</strong> proviene de
            la combinación de varias tecnologías fundamentales.
          </p>
          <ul>
            <li>
              <strong>Procesos de Linux:</strong> cada proceso tiene su propio
              espacio de memoria virtual, separado de los demás, y se crean y
              destruyen rápidamente.
            </li>
            <li>
              <strong>Namespaces de Linux:</strong> controlan lo que una
              aplicación puede ver, como identificadores de proceso, árboles de
              directorios, direcciones IP y más. (Nota: los namespaces de Linux{" "}
              <strong>no son lo mismo</strong> que los namespaces de Kubernetes).
            </li>
            <li>
              <strong>cgroups (control groups):</strong> limitan los recursos
              que una aplicación puede usar, incluyendo CPU, memoria, ancho de
              banda de I/O y otros.
            </li>
            <li>
              <strong>Sistemas de archivos en capas (union file systems):</strong>{" "}
              permiten encapsular aplicaciones y sus dependencias en capas
              limpias y mínimas.
            </li>
          </ul>
          <h4>Imágenes de contenedor</h4>
          <p>
            Una <strong>imagen de contenedor</strong> está estructurada en
            capas. Se construye usando instrucciones de un archivo de manifiesto
            (por ejemplo, un <strong>Dockerfile</strong> en Docker).
          </p>
          <ul>
            <li>
              Cada instrucción del Dockerfile genera una{" "}
              <strong>capa dentro de la imagen</strong>, que es de solo lectura.
            </li>
            <li>
              Cuando se ejecuta el contenedor, se añade una{" "}
              <strong>capa superior temporal y escribible</strong>, permitiendo
              cambios efímeros sin afectar la imagen base.
            </li>
          </ul>
        </div>

        <div id="dockerfile" class="content-card">
          <h3>Capas en un Dockerfile</h3>
          <p>
            Un <strong>Dockerfile</strong> crea una imagen de contenedor a
            partir de varias capas, cada una generada por un comando diferente.
            Aunque este ejemplo es simplificado, ilustra cómo se estructuran las
            imágenes modernas.
          </p>
          <ul>
            <li>
              <strong>FROM:</strong> crea la capa base, generalmente obtenida de
              un repositorio público. En este caso, se usa un entorno de
              ejecución de Ubuntu de una versión específica.
            </li>
            <li>
              <strong>COPY:</strong> agrega una nueva capa con archivos copiados
              desde el directorio actual del build tool.
            </li>
            <li>
              <strong>RUN:</strong> construye la aplicación usando un comando
              como <code>make</code> y coloca los resultados en una tercera
              capa.
            </li>
            <li>
              <strong>CMD (o ENTRYPOINT):</strong> define qué comando se
              ejecutará dentro del contenedor al iniciarlo.
            </li>
          </ul>
          <h4>Detalles importantes</h4>
          <ul>
            <li>
              Cada capa representa solo{" "}
              <strong>las diferencias respecto a la capa anterior</strong>, lo
              que hace que las imágenes sean eficientes.
            </li>
            <li>
              Al escribir un Dockerfile, se recomienda{" "}
              <strong>
                ordenar las instrucciones desde las capas menos propensas a
                cambiar hasta las más propensas a cambiar
              </strong>, para optimizar la reutilización de capas en futuras
              construcciones.
            </li>
          </ul>
          <div class="image-container">
            <img
              src="/DevSecOps/GoogleDevOpsSRE/arch03.png"
              alt="Capas en un Dockerfile"
              loading="lazy"
            />
          </div>
        </div>

        <div id="buenas-practicas" class="content-card">
          <h3>Buenas prácticas y capas escribibles en contenedores</h3>
          <p>
            Actualmente, la mejor práctica es{" "}
            <strong>
              no construir tu aplicación en el mismo contenedor que vas a
              desplegar y ejecutar
            </strong>. Esto evita que herramientas de construcción innecesarias
            aumenten la complejidad o se conviertan en un vector de ataque.
          </p>
          <ul>
            <li>
              <strong>Construcción multi-stage:</strong> un contenedor se
              encarga de construir la aplicación, mientras que otro contenedor
              recibe solo lo necesario para ejecutarla.
            </li>
            <li>
              <strong>Capa escribible del contenedor:</strong> al iniciar un
              contenedor, el runtime agrega una nueva capa superior donde se
              pueden hacer cambios.
            </li>
            <li>
              Escribiendo nuevos archivos, modificando existentes o eliminando
              archivos.
            </li>
            <li>
              Esta capa es <strong>efímera</strong>: al eliminar el contenedor,
              los cambios se pierden.
            </li>
            <li>
              <strong>Integridad de la imagen base:</strong> la imagen
              subyacente permanece inalterada, incluso después de modificar la
              capa escribible.
            </li>
            <li>
              <strong>Almacenamiento de datos persistente:</strong> para guardar
              datos de manera permanente, deben almacenarse fuera del contenedor
              en ejecución.
            </li>
            <li>
              <strong>Compartición de imágenes:</strong> múltiples contenedores
              pueden usar la misma imagen base mientras mantienen estados de
              datos independientes en sus capas escribibles.
            </li>
          </ul>
        </div>

        <div id="uso-imagenes" class="content-card">
          <h3>Uso de imágenes de contenedor y herramientas de construcción</h3>
          <p>
            Cuando se construye un contenedor,{" "}
            <strong>no se copia toda la imagen</strong>, sino solo una capa con
            las diferencias. Esto hace que la construcción, ejecución y
            actualización de contenedores sea mucho más rápida que usar máquinas
            virtuales completas.
          </p>
          <ul>
            <li>
              <strong>Capas de diferencias:</strong>
              <ul>
                <li>
                  Al ejecutar un contenedor, el runtime descarga únicamente las
                  capas necesarias.
                </li>
                <li>
                  Al actualizar una imagen, solo se copian las diferencias,
                  acelerando los despliegues.
                </li>
              </ul>
            </li>
            <li>
              <strong>Imágenes base públicas:</strong> se suelen usar imágenes
              open-source como punto de partida o para uso directo.
              <ul>
                <li>
                  Ejemplos: <code>ubuntu</code> (entorno Linux),{" "}
                  <code>alpine</code> (Linux muy ligero), <code>nginx</code> (servidor
                  web).
                </li>
              </ul>
            </li>
            <li>
              <strong>Registro de imágenes:</strong>
              <ul>
                <li>
                  <strong>Artifact Registry:</strong> almacena imágenes de
                  contenedor, paquetes de lenguaje y de sistema operativo.
                </li>
                <li>
                  Integración con otros servicios de Google Cloud: IAM (control
                  de acceso), KMS (encriptación), Cloud Build (CI/CD), Container
                  Analysis (análisis de vulnerabilidades).
                </li>
                <li>
                  Otras fuentes públicas: Docker Hub, GitLab, y más.
                </li>
              </ul>
            </li>
            <li>
              <strong>Construcción de contenedores:</strong>
              <ul>
                <li>
                  La herramienta <code>docker</code> es muy popular y
                  ampliamente usada, pero requiere confiar en la máquina donde
                  se realizan los builds.
                </li>
                <li>
                  Google Cloud ofrece <strong>Cloud Build</strong>, un servicio
                  gestionado integrado con IAM que automatiza la construcción de
                  contenedores.
                </li>
              </ul>
            </li>
            <li>
              <strong>Cloud Build:</strong>
              <ul>
                <li>
                  Recupera código de repositorios como Cloud Source
                  Repositories, GitHub o Bitbucket.
                </li>
                <li>
                  Permite definir pasos de build: instalar dependencias,
                  compilar código, ejecutar tests o usar herramientas como
                  Docker, Gradle o Maven.
                </li>
                <li>Cada paso se ejecuta en un contenedor Docker.</li>
                <li>
                  Puede entregar las imágenes construidas a entornos de
                  ejecución como GKE, App Engine o Cloud Functions.
                </li>
              </ul>
            </li>
          </ul>
          <div class="image-container">
            <img
              src="/DevSecOps/GoogleDevOpsSRE/arch04.png"
              alt="Cloud Build"
              loading="lazy"
            />
          </div>
        </div>
      </Contenido>
    </main>
  </div>
</BaseLayout>
<style>
  @import "../../../../../styles/gcp-content.css";
</style>
